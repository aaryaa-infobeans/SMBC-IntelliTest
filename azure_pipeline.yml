trigger:
  - azureTest

parameters:
  - name: parallel
    displayName: 'Run tests in parallel? (true/false)'
    type: string
    default: 'false'
  - name: workers
    displayName: 'Number of parallel workers (optional)'
    type: string
    default: ''
  - name: split_level
    displayName: 'Split level (module/test_file)'
    type: string
    default: 'module'
    values:
    - 'module'
    - 'test_file'
  - name: test_args
    displayName: 'Extra pytest arguments (optional)'
    type: string
    default: ''
  - name: testplan
    displayName: 'Test Plan Key (optional)'
    type: string
    default: ''
  - name: TestExecutionId
    displayName: 'Test Execution ID (optional)'
    type: string
    default: ''
  - name: test_case_ids
    displayName: 'Test Case IDs (comma-separated)'
    type: string
    default: ''
  - name: generate_report
    displayName: 'Generate test report?'
    type: boolean
    default: true
  - name: notify_email
    displayName: 'Send email notification?'
    type: boolean
    default: true
  - name: notify_slack
    displayName: 'Send Slack notification?'
    type: boolean
    default: false

variables:
  python.version: '3.11'
  BASE_URL: 'https://www.saucedemo.com/v1/'
  ALLURE_RESULTS_DIR: 'allure-results'
  PYTEST_HTML_REPORT: 'pytest-report.html'
  JUNIT_XML: 'junit-report.xml'

stages:
- stage: BuildAndTest
  jobs:
  - job: StaticCodeAnalysis
    pool:
      vmImage: 'windows-latest'
    steps:
    - task: UsePythonVersion@0
      inputs:
        versionSpec: '$(python.version)'
        addToPath: true
    
    - script: python -m pip install --upgrade pip
      displayName: 'Upgrade pip'
    
    - script: |
        pip install -r requirements.txt
        pip install -r requirements-dev.txt
      displayName: 'Install dependencies'
    
    # Black code formatting check
    - script: |
        pip install black
        black --check . | tee black-report.log
      displayName: 'Run Black'
      continueOnError: true
    
    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: 'black-report.log'
        ArtifactName: 'black-format-report'
      displayName: 'Publish Black Report'
      condition: always()
    
    # Isort import sorting check
    - script: |
        pip install isort
        isort --check-only . | tee isort-report.log
      displayName: 'Run Isort'
      continueOnError: true
    
    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: 'isort-report.log'
        ArtifactName: 'isort-report'
      displayName: 'Publish Isort Report'
      condition: always()
    
    # Pylint check
    - script: |
        pip install pylint
        pylint --rcfile=pyproject.toml SRC Utilities TestDataCommon | tee pylint-report.log
      displayName: 'Run Pylint'
      continueOnError: true
    
    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: 'pylint-report.log'
        ArtifactName: 'pylint-report'
      displayName: 'Publish Pylint Report'
      condition: always()

  - job: TestExecution
    dependsOn: StaticCodeAnalysis
    condition: succeeded('StaticCodeAnalysis')
    pool:
      vmImage: 'ubuntu-latest'
    steps:
    - checkout: self
      fetchDepth: 0
    
    - task: UsePythonVersion@0
      inputs:
        versionSpec: '$(python.version)'
        addToPath: true
    
    - script: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install allure-pytest pytest-html pytest-xdist
        python -m playwright install
      displayName: 'Install dependencies'
    
    - powershell: |
        # Base pytest command
        $testCommand = "pytest -v"
        
        # Add HTML and JUnit reporting if report generation is enabled
        if (${{ parameters.generate_report }} -eq 'true') {
          $testCommand += " --html=$(PYTEST_HTML_REPORT) --junitxml=$(JUNIT_XML) --alluredir=$(ALLURE_RESULTS_DIR)"
        }
        
        # Add parallel execution if enabled
        if ('${{ parameters.parallel }}' -eq 'true') {
          $workers = if ('${{ parameters.workers }}') { "-n $(${{ parameters.workers }} )" } else { "-n auto" }
          $testCommand += " $workers"
          
          # Add split by module or test file if specified
          if ('${{ parameters.split_level }}' -eq 'module') {
            $testCommand += " --dist=loadscope"
          }
        }
        
        # Add test case filtering if test case IDs are provided
        if ('${{ parameters.test_case_ids }}') {
          $testIds = '${{ parameters.test_case_ids }}' -split ',' | ForEach-Object { $_.Trim() }
          $testExpression = $testIds -join ' or '
          $testCommand += " -k '$testExpression'"
        }
        
        # Add additional test arguments if provided
        if ('${{ parameters.test_args }}') {
          $testCommand += " $(${{ parameters.test_args }})"
        }
        
        Write-Host "##vso[task.setvariable variable=testCommand]$testCommand"
        Write-Host "Test command prepared: $testCommand"
      displayName: 'Prepare test command'
    
    # Run tests
    - script: |
        echo "Running tests with command: $(testCommand)"
        $(testCommand)
      displayName: 'Run tests'
      continueOnError: true
    
    # Publish test results
    - task: PublishTestResults@2
      inputs:
        testResultsFormat: 'JUnit'
        testResultsFiles: '$(JUNIT_XML)'
        testRunTitle: 'Pytest Results'
      condition: always()
    
    # Publish HTML report
    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: '$(PYTEST_HTML_REPORT)'
        ArtifactName: 'pytest-html-report'
      displayName: 'Publish Pytest HTML Report'
      condition: always()
    
    # Publish Allure results
    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: '$(ALLURE_RESULTS_DIR)'
        ArtifactName: 'allure-results'
      displayName: 'Publish Allure Results'
      condition: always()
    
    # Generate and publish Allure report
    - script: |
        pip install allure-pytest-commons
        allure generate $(ALLURE_RESULTS_DIR) -o allure-report --clean
      displayName: 'Generate Allure Report'
      condition: always()
    
    - task: PublishBuildArtifacts@1
      inputs:
        PathtoPublish: 'allure-report'
        ArtifactName: 'allure-report'
      displayName: 'Publish Allure Report'
      condition: always()
    
    # Send email notification
    - task: PowerShell@2
      displayName: 'Send Email Notification'
      condition: always()
      inputs:
        targetType: 'inline'
        script: |
          $status = 'Succeeded'
          if (Test-Path '$(System.DefaultWorkingDirectory)/$(JUNIT_XML)') {
            [xml]$testResults = Get-Content '$(System.DefaultWorkingDirectory)/$(JUNIT_XML)'
            $total = $testResults.testsuites.tests
            $failures = $testResults.testsuites.failures
            $errors = $testResults.testsuites.errors
            $skipped = $testResults.testsuites.skipped
            
            if (($failures -gt 0) -or ($errors -gt 0)) {
              $status = 'Failed'
            }
            
            $body = @{
              text = "Test execution $status`n" +
                     "Total: $total, Failed: $failures, Errors: $errors, Skipped: $skipped`n" +
                     "Build URL: $(System.CollectionUri)$(System.TeamProject)/_build/results?buildId=$(Build.BuildId)"
            }
            
            # Convert to JSON and output for debugging
            $bodyJson = $body | ConvertTo-Json
            Write-Host $bodyJson
            
            # Here you would add code to send the email using your preferred method
            # For example, using Send-MailMessage or an API call to your email service
          } else {
              Write-Host "Test results file not found"
          }
    
    - task: PowerShell@2
      displayName: 'Send Email Notification'
      condition: always()
      inputs:
        targetType: 'inline'
        script: |
          $smtpServer = "smtp.gmail.com"
          $smtpFrom = "$(gmailFrom)"
          $smtpTo = "$(gmailTo)"
          $smtpUser = "$(gmailUser)"
          $smtpPass = "$(gmailAppPassword)"
          
          $buildId = "$(Build.BuildId)"
          $buildNumber = "$(Build.BuildNumber)"
          $collectionUri = "$(System.CollectionUri)"
          $teamProject = "$(System.TeamProject)"
          $buildUri = "${collectionUri}${teamProject}/_build/results?buildId=${buildId}&view=results"
          $buildStatus = "$(Agent.JobStatus)"

          # Variables are available directly
          $subject = "Build Results for $teamProject-$buildNumber"
          $body = "The build has $buildStatus. `nCheck: $buildUri`nPlease find the attached HTML report. `n`nThanks,`nBuild Automation Team`n-Infobeans"
          $attachment = "$(System.DefaultWorkingDirectory)/pytest_html_report.html"

          $smtp = New-Object Net.Mail.SmtpClient($smtpServer, 587)
          $smtp.EnableSsl = $true
          $smtp.Credentials = New-Object System.Net.NetworkCredential($smtpUser, $smtpPass);
          $message = New-Object Net.Mail.MailMessage($smtpFrom, $smtpTo, $subject, $body)
          $message.Attachments.Add($attachment)
          $smtp.Send($message)
